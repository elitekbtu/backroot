<!DOCTYPE html>
<html>
<head>
    <title>Audio Format Test</title>
</head>
<body>
    <h1>Audio Format Test</h1>
    <button id="startBtn">Start Recording</button>
    <button id="stopBtn" disabled>Stop Recording</button>
    <div id="output"></div>

    <script>
        let mediaRecorder;
        let audioChunks = [];

        document.getElementById('startBtn').onclick = async () => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 16000
                    }
                });

                // Try different audio formats
                const formats = [
                    'audio/mp4',
                    'audio/wav', 
                    'audio/webm',
                    'audio/ogg;codecs=opus'
                ];

                let mimeType = 'audio/mp4';
                for (const format of formats) {
                    if (MediaRecorder.isTypeSupported(format)) {
                        mimeType = format;
                        break;
                    }
                }

                console.log('Using audio format:', mimeType);
                document.getElementById('output').innerHTML += `<p>Using format: ${mimeType}</p>`;

                mediaRecorder = new MediaRecorder(stream, { mimeType });
                audioChunks = [];

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                        console.log('Audio chunk received, size:', event.data.size, 'type:', event.data.type);
                        document.getElementById('output').innerHTML += `<p>Chunk: ${event.data.size} bytes, type: ${event.data.type}</p>`;
                    }
                };

                mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(audioChunks, { type: mimeType });
                    console.log('Final audio blob:', audioBlob.type, audioBlob.size);
                    document.getElementById('output').innerHTML += `<p>Final blob: ${audioBlob.type}, ${audioBlob.size} bytes</p>`;
                    
                    // Test base64 encoding
                    const reader = new FileReader();
                    reader.onload = () => {
                        const audioData = reader.result;
                        const base64Audio = audioData.split(',')[1];
                        console.log('Base64 length:', base64Audio.length);
                        document.getElementById('output').innerHTML += `<p>Base64 length: ${base64Audio.length}</p>`;
                    };
                    reader.readAsDataURL(audioBlob);
                };

                mediaRecorder.start(1000); // Record for 1 second chunks
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
            } catch (error) {
                console.error('Error:', error);
                document.getElementById('output').innerHTML += `<p>Error: ${error.message}</p>`;
            }
        };

        document.getElementById('stopBtn').onclick = () => {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
            }
        };
    </script>
</body>
</html>